* {
    margin: 0;
    padding: 0;
}

header {
    background-color: rgba(35, 28, 26, 0.8);/*这个是设置了导览列的透明度*/
    height: 80px;
    width: 100%;
    /*position: relative;一开始设计的是这样子，但是后面我希望他可以在我视窗向下滚动时导览列会固定在银幕上方*/
    position: fixed;/*这个是固定的意思，有了这个，当我们滚动屏幕时，导览列就会跟着一起了*//*不过要注意，当我们设置成fixed后整个版面会向上偏移，递补导览列原先所占的空间，要保持原样就要调整“.news的height”和“.news h2的margin-top”
    /*分为相对（relative）和绝对（absolute）这两种，使用相对时，元素会从原本的位置开始移动*/
}

header ul {
    position: absolute;/*从版面（父元素）的左上角开始计算，*/
    right: 15vw;
    top: 0;
    line-height: 80px;/*本行与上一行和下一行的间距*/
    color: white;
    font-size: 20px;
}

header li {
    display: inline;/*由于导览列的li标签是区块元素，所以每个链接都会独占一整行，呈现上下相叠的状态，所以我就使用display把他转成行内元素，让导览列变成横式的排列*/
    margin-right: 6vw;/*同时加大每个按钮的右边距 ，这里有一个相对单位vw（viewport width），这里代表的是视窗宽度的4% ，使用相对单位的好处是当视窗的大小发生改变时，vw的宽度也会配合视窗宽度的大小进行改变 */
}

header a {
    color: white;
    text-decoration: none;/*这个是用了清理导览列文字（就是最新消息那几个）下面的链接语法所剩下了的底线*/
}/*这是<header>元素里面所有的a标签*/

header a:hover {
    text-decoration: underline;/*这个就是让我的鼠标移动到导览列文字时出现下面的底线*/
}



.computing-power {
display: flex;
align-items: center;
flex-direction: column;
justify-content: center;
height: 85vw;
border-bottom: 3px solid black;
}

.computing-power h2 {
    font-size: 60px;
    margin-bottom: 60px;
    border-left: 4px black solid;
    border-right: 4px black solid; 
    padding: 0 15px;
}

.computing-power p {
    font-size: 22px;
    margin: 20px 0;
    border-bottom:3px black solid ;
}

.computing-power a {
    text-decoration: none;
    border: 1px solid #ACACAC;
    padding: 10px 20px;
    border-radius: 5px;
    color: black;
    margin-top: 20px;
}

.history {
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    border-bottom: 3px solid black;
}

.history h2 {
    font-size: 60px;
    margin-top: 60px;
    border-right: 3px black solid;
    border-left: 3px black solid;
    padding: 0 20px;
    margin-bottom: 30px;
    
}

.history div h3 {/*因为div相当于切断了h3与.history的命令，因此。history的命令h3应用不到，所以要把.history的命令单独引下来*/
    margin-top: 60px;
    border-right: 3px black solid;
    border-left: 3px black solid;
    font-size: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
}

.history  p {
    font-size: 30px;
}

.history img {
    background-size: cover;/*但是，使用上面的语法后又会导致边框拼接的部分没有显示，因此，使用这个命令调整图片的大小*/
    background-position: center ;/*上面的一个语法虽然让图片填满了整个容器，但同时也可能会超过容器的边界，因此把图片置中与整个区块*/
    width: 100%;
}

.figure {
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
}

.figure img {
    background-size: cover;/*但是，使用上面的语法后又会导致边框拼接的部分没有显示，因此，使用这个命令调整图片的大小*/
    background-position: center ;/*上面的一个语法虽然让图片填满了整个容器，但同时也可能会超过容器的边界，因此把图片置中与整个区块*/
    width: 50%;
    margin-top: 25px;
}

.figure h2 {
    font-size: 60px;
    margin-top: 60px;
    border-right: 3px black solid;
    border-left: 3px black solid;
    padding: 0 20px;
    margin-bottom: 30px;
}

.technology {
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
}

.technology h2 {
    font-size: 60px;
    margin-top: 60px;
    border-right: 3px black solid;
    border-left: 3px black solid;
    padding: 0 20px;
    margin-bottom: 30px;
}

.technology img {
    background-size: cover;/*但是，使用上面的语法后又会导致边框拼接的部分没有显示，因此，使用这个命令调整图片的大小*/
    background-position: center ;/*上面的一个语法虽然让图片填满了整个容器，但同时也可能会超过容器的边界，因此把图片置中与整个区块*/
    margin-top: 25px;
    width: 100%;
}

body {
    background-color: white;
}

section {
    background-color: antiquewhite;
}


.news {
    overflow: hidden; /* 隐藏超出部分 */
    border-right: .15em solid orange; /* 光标效果 */
    white-space: nowrap; /* 防止换行 */
    align-items: center;
    justify-content: center;
    letter-spacing: .15em; /* 字符间距 */
    
  }

  /* 打字动画试验地 */
  .news {
    display: inline-block;
    animation: typing 3.5s steps(40, end), blink-caret .75s step-end infinite;
  }

  .news h2 {
    font-size: 60px;
  }

  /* 打字动画关键帧 */
  @keyframes typing {
    from {
      width: 0; /* 文本宽度为0，即隐藏 */
    }
    to {
      width: 100%; /* 文本宽度为100%，完全显示 */
    }
  }

  /* 光标闪烁动画 */
  @keyframes blink-caret {
    from,
    to {
      border-color: transparent; /* 光标透明 */
    }
    50% {
      border-color: antiquewhite; /* 光标颜色 */
    }
  }

  .typewriter {
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    height: 50%;
    background-color: antiquewhite;
    padding-top: 300px;
  }

