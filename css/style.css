* {
    margin: 0;
    padding: 0;
}

header {
    background-color: rgba(35, 28, 26, 0.8);/*这个是设置了导览列的透明度*/
    height: 80px;
    width: 100%;
    /*position: relative;一开始设计的是这样子，但是后面我希望他可以在我视窗向下滚动时导览列会固定在银幕上方*/
    position: fixed;/*这个是固定的意思，有了这个，当我们滚动屏幕时，导览列就会跟着一起了*//*不过要注意，当我们设置成fixed后整个版面会向上偏移，递补导览列原先所占的空间，要保持原样就要调整“.news的height”和“.news h2的margin-top”
    /*分为相对（relative）和绝对（absolute）这两种，使用相对时，元素会从原本的位置开始移动*/
}

header ul {
    position: absolute;/*从版面（父元素）的左上角开始计算，*/
    right: 15vw;
    top: 0;
    line-height: 80px;/*本行与上一行和下一行的间距*/
    color: white;
    font-size: 20px;
}

header li {
    display: inline;/*由于导览列的li标签是区块元素，所以每个链接都会独占一整行，呈现上下相叠的状态，所以我就使用display把他转成行内元素，让导览列变成横式的排列*/
    margin-right: 6vw;/*同时加大每个按钮的右边距 ，这里有一个相对单位vw（viewport width），这里代表的是视窗宽度的4% ，使用相对单位的好处是当视窗的大小发生改变时，vw的宽度也会配合视窗宽度的大小进行改变 */
}

header a {
    color: white;
    text-decoration: none;/*这个是用了清理导览列文字（就是最新消息那几个）下面的链接语法所剩下了的底线*/
}/*这是<header>元素里面所有的a标签*/

header a:hover {
    text-decoration: underline;/*这个就是让我的鼠标移动到导览列文字时出现下面的底线*/
}

.news {
    color: black;
    height: 55vw;
    display: flex;/*这个使元素区块中的子元素全部在一排里面横着排放*/
    flex-direction: column;/*因为上面的语法使子元素全部横着排放，如果想让子元素纵向堆叠，则使用这个语法，这个语法的意思是flex方向为column（栏）*/
    align-items: center;/*使子元素水平对齐为中央*/
    justify-content: center;/*垂直对齐也是中央*/
    
}

.news h2 {
    font-size: 60px;
    margin-top: 60px;/*一开始这个是没有的，因为header从relativ改成了fiexd*，具体原因可以去header那里看*/
}

.computing-power {
display: flex;
align-items: center;
flex-direction: column;
justify-content: center;
height: 85vw;
border-bottom: 3px solid black;
}

.computing-power h2 {
    font-size: 60px;
    margin-bottom: 60px;
    border-left: 4px black solid;
    border-right: 4px black solid; 
    padding: 0 15px;
}

.computing-power p {
    font-size: 22px;
    margin: 20px 0;
    border-bottom:3px black solid ;
}

.computing-power a {
    text-decoration: none;
    border: 1px solid #ACACAC;
    padding: 10px 20px;
    border-radius: 5px;
    color: black;
    margin-top: 20px;
}

.history {
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
}

.history h2 {
    font-size: 60px;
    margin-top: 60px;
    border-right: 3px black solid;
    border-left: 3px black solid;
    padding: 0 20px;
    margin-bottom: 30px;
}

.history  p {
    font-size: 30px;
}

.history img {
    background-size: cover;/*但是，使用上面的语法后又会导致边框拼接的部分没有显示，因此，使用这个命令调整图片的大小*/
    background-position: center ;/*上面的一个语法虽然让图片填满了整个容器，但同时也可能会超过容器的边界，因此把图片置中与整个区块*/
    width: 100%;
}

.figure {
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
}

.figure img {
    background-size: cover;/*但是，使用上面的语法后又会导致边框拼接的部分没有显示，因此，使用这个命令调整图片的大小*/
    background-position: center ;/*上面的一个语法虽然让图片填满了整个容器，但同时也可能会超过容器的边界，因此把图片置中与整个区块*/
    width: 50%;
    margin-top: 25px;
}

.figure h2 {
    font-size: 60px;
    margin-top: 60px;
    border-right: 3px black solid;
    border-left: 3px black solid;
    padding: 0 20px;
    margin-bottom: 30px;
}

body {
    background-color: white;
}

section {
    background-color: antiquewhite;
}




